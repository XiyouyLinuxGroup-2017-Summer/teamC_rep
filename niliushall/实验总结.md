## <center> **实验总结**</center>

----

### 1. 进程控制

	该题运行结果为每次输出10个进程的信息，每次输出之间间隔2秒，且进程输出顺序在变化，如果输入数字并按回车，会将对应的进程终止
  (此时成为僵尸进程)，而且输出的时候被终止进程的信息也不再输出，按下q后杀死所有进程。而且输出的时候每个进程内的序号、全局变量是
  不同的，因为各进程的堆栈区等资源是独立的、互不影响，在给全局变量等赋值时，是在独立的内存中赋值，因此输出时每个进程的信息不同。

	在使用kill杀死进程时，会使进程立即终止，而且没有后续的回收处理，相比于return、exit等（退出后会回收处理占用的资源），会存在隐
  患，可能会出现莫名其妙的问题。所以最好使用exit等函数来退出进程。还要注意紫禁城不能用return来退出，否则会造成父进程的资源也被回
  收，导致段错误。

	kill函数第一个参数大于0时，会杀死对应的进程，当第一个参数等于0时，会杀死当前进程组的所有进程。

###2. 线程控制

```
/*部分代码*/

/*第一部分*/

counter[thread_num]++; 
main_counter++;           //----  1

/*第二部分*/

 do
    {

        unsigned long long sum = 0;    

        for (i=0; i<MAX_THREAD; i++)
        {  
            sum += counter[i];                       // ---- 2
            printf("%llu ", counter[i]);   
        }
        printf("%llu/%llu", main_counter, sum);   
    }while ((ch = getchar()) != 'q'); 
```
	若直接运行此程序，会产生多种错误(与预想的每行最后两列值相等不符，且会有大于和小于两种情况的发生)。

	先说第一种小于的情况，因为自加 ( 代码中1处 ) 的操作并非原子操作，需要t = i, t += 1, i = t三步才可以完成自加,
  即可以被打断其运行，若一个线程在前两步被打断（设此时t = 100），而其他线程又对i进行自加到了i = 120,此时第一个线
  程继续运行，问题出现了，现在t加1后再赋给i，此后i的自加是从101开始的，并非从预想的120开始自加，所以i最终的值会小
  于实际应该的值。

	再说第二种大于的情况，问题在代码中2处，同样因为线程调度的原因，线程可能在sum把count[i]加和后，线程停止，其他线程
  运行，导致在其他线程中count[i]的值又自加了（例如代码1处），而在输出时则输出已经加和的sum，而不是数值改变后的和，
  所以数值看起来会变小。

解决办法:

	既然我们已经找到了问题发生的原因，也就是某线程的非原子操作可能会发生中断，导致其他线程修改了本线程将要使用变量的值，
  那么我们就要想办法让本线程在操作完之前其他线程不会改变将要使用或已使用变量的值，所以互斥量在此时就发挥出了作用。设置
  互斥量后就保证了当前进程对某些变量的“绝对占有权”，避免了其他线程对其影响。  


```
/*修改的第一部分*/

counter[thread_num]++; 
pthread_mutex_lock(&mutex); //加锁
main_counter++;           //----  1
pthread_mutex_unlock(&mutex);//解锁

/*修改的第二部分*/

 do
    {

        unsigned long long sum = 0;    

        pthread_mutex_lock(&mutex);  //加锁
        for (i=0; i<MAX_THREAD; i++)
        {  
            sum += counter[i];                       // ---- 2
            printf("%llu ", counter[i]);   
        }
        printf("%llu/%llu", main_counter, sum);   
        pthread_mutex_unlock(&mutex);  //解锁
    }while ((ch = getchar()) != 'q'); 
```

###3. 互斥实验

	现象及原因:

	该代码由于加锁顺序不同，可能一个线程在代码段1处先给mutex1加锁，将mutex1阻塞，然后暂停运行，被
  另一线程抢夺了使用cpu的权限，而另一线程刚好又在代码段2处对mutex2进行了加锁，将mutex2阻塞。此
  时mutex1需要调用mutex2，而mutex2需要调用mutex1，然而更加不幸的是两者都被阻塞，等待对方被释放
  ，悲剧就此产生，两个固执的线程都在等待对方收手，而这是不可能发生的事，所以就这样僵持下去，死锁现
  象也就出现了。

	解决方法:

	很简单，将加锁顺序修改的相同即可。都先锁1，后锁2，反之亦可。
