第三周，感觉比第二周要好那么一些吧。主要还是学习了一些关于线程方面的知识，再加上平时刷题写写代码，感觉还算的上充实，但总感觉生活方面有些惨淡，周一的下午想换个吃饭的地方，便回了西区的没事广场，谁曾想第二天上午闹了一上午的肚子/(ㄒoㄒ)/~~那感觉真的很惨。宿舍也是人去楼空，一层只有自己一个人住，回去之后情绪也比较压抑，基本啥都不想看了，心里总是不踏实。不过星期六的下午大家一块出去玩，虽然很累，同时也很快乐，也算是留校期间最浪的一天。
##算法题##
感觉也没什么，这个星期的题相对于上个星期但感觉难度有些下降，更多都是小问题映射出一种很常用的思考问题的方法。其实并没有太多难度，主要在于自己对问题的理解和思考。
##Linux C##
线程方面
线程
> 程是计算机中独立运行的最小单位，运行时占用很少的系统资源。在用户看来，多个线程是同时执行，但从操作系统调度来看，各个线程是交替执行。系统不停的在各个线程之间切换，每个线程只有在系统分配给它的时间片内才能取得CPU的控制权，执行线程中的代码。 

线程的创建

```
#include <pthread.h>

int pthread_create(pthread_t thread,pthread_attr_t *attr,void *(*start_routine)(void *),void *arg);
参数
thread:指针，返回创建的线程ID
attr:该参数返回线程属性的结构体，NULL表示默认属性
start_routine:函数指针，创建函数后要调用的函数,也称线程函数
arg:该参数指向传递给线程函数的参数
```
线程终止

> 通过return从线程函数返回
通过调用函数pthread_exit()使线程退出
调用pthread_cancel()取消线程
任意线程调用exit()，或着主线程执行return,都会导致进程中的左右县测过立即终止
资源的处理
pthread_cleanu_push()、pthread_cleanup_pop()用于自动释放资源，从pthread_cleanup_push()调用点到pthread_cleanup_pop()之间的程序段中的终止动作都将执行pthread_cleanup_push() 所指定的清理函数（注意这两个函数必须成对存在） 

私有数据 
在多线程环境下，进程内的所有线程共享进程的数据空间，因此全局变量为所有线程共有，在程序设计中有时需要保存线程自己的全局变量，这还总特殊的变量尽在某个线程内部有效。比如常见的变量errno，它返回标准的出错码。errno不应该是一个局部变量，否则在一个线程里输出的很可能是另一个线程的出错信息，这个问题可以通过创建线程的私有数据(TSD)来解决。在线程内部，线程私有数据可以被各个函数访问，但它对其他线程是屏蔽的。 
私有数据采用了一种被称为一键多值的技术，即一个键对应多个数。访问数据时都是通过键值来访问，好象是对一个变量进行访问，其实在访问不同的数据。
线程同步 

> 互斥锁通过锁机制来实现线程间的同步，在同一个时刻它通常只允许一个线程执行一个关键部分的代码。 
使用互斥锁前必须先进行初始化操作。初始化有两种方式，一种是静态赋值法，将宏结构常量赋给互斥锁，另外一种方式是通过pthread_mutex_init函数初始化互斥锁。初始化后就可以给给互斥锁加锁了。加锁有两个函数:pthread_mutex_lock()和pthread_mutex_unlock()。 
用pthread_mutex_lock()加锁的时候，如果mutex已经被锁住，当前尝试加锁的进程就会阻塞，知道互斥锁被其他线程释放，当pthread_mutex_lock函数返回时，说明互斥锁已经被当前进程成功加锁。pthread_mutex_trylock函数则不同，如果mutex已经被加锁，它将立即返回，返回的错误码为EBUSY，而不是阻塞等待。 
用pthread_mutex_unlock函数解锁时，要满足两个条件：意识互斥锁必须处于加锁状态，而是调用本函数的线程必须是给互斥锁加锁的线程。解锁后如果有其他线程在等待互斥锁，等待队列中的第一个将获得互斥锁。 
当一个互斥锁使用完毕后，必须进行清除，清除互斥锁使用函数pthread_mutex_destroy。 
清除一个互斥锁意味着释放它所占用的资源。清除锁时要求当前处于开放状态，若锁处于锁定状态，函数放回EBUSY，该函数成功之行时返回0。由于在Linux中，互斥锁并不占用内存，因此pthread_mutex_destroy()除了解除互斥锁的状态外没有其他操作。
条件变量 
条件变量是利用线程见共享的全局变量进行同步的一种机制。条件变量宏观上类似if语句，符合条件就能执行某段程序，否则只能等待条件成立。 
使用条件变量主要包括两个动作：一个等待使用资源的线程等待”条件变量被设置为真”;另一个线程在使用完资源后”设置条件为真”，这样就可以保证线程间的同步了。这样就存在一个关键问题，这就是要保证条件变量能被正确的修改，条件变量要受到特殊的保护，实际使用中互斥锁扮演者这样一个保护者的角色。Linux也提供了一系列对条件变量操作的函数。 
与互斥锁一样，条件变量的初始话也有两种方式，一种是静态赋值法，将宏结构常量PTHREAD_COND_INITIALIZER赋给互斥锁。另一种方式是使用函数pthread_cond_init。 
pthread_cond_wait函数释放有mutex指向的互斥锁，同时使当前线程关于cond所指向的条件变量阻塞，直到条件被信号唤醒。通常条件表达式在互斥锁的保护下求值，如果条件表达式为假，那么线程基于条件变量阻塞。当一个线程改变条件变量的同时，条件变量获得一个信号，使得条件变量的线程退出阻塞状态。 
pthread_cond_timedwait函数和pthread_cond_wait函数用法类似，差别在于pthread_cond_timedwait函数将阻塞直到条件变量获得信号或者经过abstime指定的时间，也就是说，rugosa再给定时刻前条件没有满足，则返回ETIMEOUT，结束等待。 
线程被条件变量阻塞后，可以通过函数pthread_cond_signal和pthread_cond_broadcast激活。 
pthread_cond_signal激活一个等待条件成立的线程，存在多个等待线程时，按入队顺序激活其中一个，而pthread_cond_broadcast则激活所有等待线程。 
当一个条件变量不再使用时，需要将其清除。清除一个条件变量通过调用pthread_cond_destroy()实现。 
pthread_cond_destroy函数清除由cond指向的条件变量。注意：只有在没有线程等待该条件变量的时候才能清除这个条件变量，否则返回EBUSY

